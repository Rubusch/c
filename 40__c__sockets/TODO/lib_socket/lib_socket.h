// lib_socket.h
/*
  based on Stevens unix network programming (1996)

  version: "Lothar's socket lib" (2007)
//*/


#ifndef __lib_socket_h
#define __lib_socket_h

// generated by scripts
#include "./config.h"

/* 
   If anything changes in the following list of #includes, must change
   acsite.m4 also, for configure's tests. 
*/
#include <sys/types.h>
#include <sys/socket.h>

#if TIME_WITH_SYS_TIME
# include <sys/time.h>               // timeval{} for select()
# include <time.h>                   // timespec{} for pselect()
#else
# if HAVE_SYS_TIME_H
#  include <sys/time.h>              // includes <time.h> unsafely
# else
#  include <time.h>                  // old system?
# endif
#endif

#include <netinet/in.h>              // sockaddr_in{} and other Internet defns
#include <arpa/inet.h>               // inet(3) functions
#include <errno.h>
#include <fcntl.h>                   // nonblocking
#include <netdb.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>                // S_xxx file mode constants
#include <sys/uio.h>                 // iovec{}, readv(), writev()
#include <unistd.h>
#include <sys/wait.h>
#include <sys/un.h>                  // Unix domain sockets

#ifdef HAVE_SYS_SELECT_H
# include <sys/select.h>
#endif

#ifdef HAVE_SYS_SYSCTL_H
#ifdef HAVE_SYS_PARAM_H
# include <sys/param.h>              // OpenBSD prereq for sysctl.h
#endif
# include <sys/sysctl.h>
#endif

#ifdef HAVE_POLL_H
# include <poll.h>
#endif

#ifdef HAVE_SYS_EVENT_H
# include <sys/event.h>              // for kqueue
#endif

#ifdef HAVE_STRINGS_H
# include <strings.h>
#endif

/* 
   Three headers are normally needed for socket/file ioctl's:
   <sys/ioctl.h>, <sys/filio.h>, and <sys/sockio.h>.
 */
#ifdef HAVE_SYS_IOCTL_H
# include <sys/ioctl.h>
#endif
#ifdef HAVE_SYS_FILIO_H
# include <sys/filio.h>
#endif
#ifdef HAVE_SYS_SOCKIO_H
# include <sys/sockio.h>
#endif

#ifdef HAVE_PTHREAD_H
# include <pthread.h>
#endif

#ifdef HAVE_NET_IF_DL_H
# include <net/if_dl.h>
#endif

#ifdef HAVE_NETINET_SCTP_H
# include <netinet/sctp.h>
#endif

/* 
   OSF/1 actually disables recv() and send() in <sys/socket.h> 
*/
#ifdef __osf__
# undef recv
# undef send
# define recv(a,b,c,d) recvfrom(a,b,c,d,0,0)
# define send(a,b,c,d) sendto(a,b,c,d,0,0)
#endif

#ifndef INADDR_NONE
# define INADDR_NONE 0xffffffff       // should have been in <netinet/in.h>
#endif

#ifndef SHUT_RD                       // these three POSIX names are new
# define SHUT_RD  0                   // shutdown for reading 
# define SHUT_WR  1                   // shutdown for writing 
# define SHUT_RDWR 2                  // shutdown for reading and writing 
#endif

#ifndef INET_ADDRSTRLEN
# define INET_ADDRSTRLEN  16          // "ddd.ddd.ddd.ddd\0" 1234567890123456
#endif

/* 
   Define following even if IPv6 not supported, so we can always allocate
   an adequately sized buffer without #ifdefs in the code. 
*/
#ifndef INET6_ADDRSTRLEN
# define INET6_ADDRSTRLEN 46          // max size of IPv6 address string:
                                      // "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx" or
                                      // "xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:ddd.ddd.ddd.ddd\0"
                                      // 1234567890123456789012345678901234567890123456 
#endif

/*
  Define bzero() as a macro if it's not in standard C library. 
*/
#ifndef HAVE_BZERO
# define bzero(ptr,n)  memset(ptr, 0, n)
#endif

/* 
   Older resolvers do not have gethostbyname2() 
*/
#ifndef HAVE_GETHOSTBYNAME2
# define gethostbyname2(host,family)  gethostbyname((host))
#endif

/*
  The structure returned by recvfrom_flags() 
*/
struct socklib_in_pktinfo{
  struct in_addr ipi_addr;           // dst IPv4 address 
  int    ipi_ifindex;                // received interface index
};

/* 
   We need the newer CMSG_LEN() and CMSG_SPACE() macros, but few
   implementations support them today.  These two macros really need
   an ALIGN() macro, but each implementation does this differently. 
*/
#ifndef CMSG_LEN
# define CMSG_LEN(size)  (sizeof(struct cmsghdr) + (size))
#endif

#ifndef CMSG_SPACE
# define CMSG_SPACE(size) (sizeof(struct cmsghdr) + (size))
#endif

/* 
   POSIX requires the SUN_LEN() macro, but not all implementations DefinE
   it (yet).  Note that this 4.4BSD macro works regardless whether there is
   a length field or not. 
*/
#ifndef SUN_LEN
# define SUN_LEN(su) \
 (sizeof(*(su)) - sizeof((su)->sun_path) + strlen((su)->sun_path))
#endif

/*
  POSIX renames "Unix domain" as "local IPC."
  Not all systems DefinE AF_LOCAL and PF_LOCAL (yet). 
*/
#ifndef AF_LOCAL
# define AF_LOCAL AF_UNIX
#endif
#ifndef PF_LOCAL
# define PF_LOCAL PF_UNIX
#endif

/*
  POSIX requires that an #include of <poll.h> DefinE INFTIM, but many
  systems still DefinE it in <sys/stropts.h>.  We don't want to include
  all the STREAMS stuff if it's not needed, so we just DefinE INFTIM here.
  This is the standard value, but there's no guarantee it is -1. 
*/
#ifndef INFTIM
#define INFTIM          (-1)         // infinite poll timeout 
#ifdef HAVE_POLL_H
#define INFTIM_SOCKLIBH                  // tell socklibxti.h we defined it
#endif
#endif

/*
  Following could be derived from SOMAXCONN in <sys/socket.h>, but many
  kernels still #define it as 5, while actually supporting many more 
*/
#define LISTENQ  1024                // 2nd argument to listen()

/* 
   Miscellaneous constants 
*/
#define MAXLINE  4096                // max text line length
#define BUFFSIZE 8192                // buffer size for reads and writes

/*
  Define some port number that can be used for our examples 
*/
#define SERV_PORT   9877             // TCP and UDP XXX check
#define SERV_PORT_STR "9877"         // TCP and UDP XXX check
#define UNIXSTR_PATH "/tmp/unix.str" // Unix domain stream
#define UNIXDG_PATH  "/tmp/unix.dg"  // Unix domain datagram

/*
  Following shortens all the typecasts of pointer arguments: 
*/
#define SA struct sockaddr

#ifndef HAVE_STRUCT_SOCKADDR_STORAGE
/*
 * RFC 3493: protocol-independent placeholder for socket addresses
 */
# define __SS_MAXSIZE 128
# define __SS_ALIGNSIZE (sizeof(int64_t))
#ifdef HAVE_SOCKADDR_SA_LEN
# define __SS_PAD1SIZE (__SS_ALIGNSIZE - sizeof(u_char) - sizeof(sa_family_t))
#else
# define __SS_PAD1SIZE (__SS_ALIGNSIZE - sizeof(sa_family_t))
#endif
#define __SS_PAD2SIZE (__SS_MAXSIZE - 2*__SS_ALIGNSIZE)

struct sockaddr_storage{
#ifdef HAVE_SOCKADDR_SA_LEN
  u_char  ss_len;
#endif
  sa_family_t ss_family;
  char  __ss_pad1[__SS_PAD1SIZE];
  int64_t  __ss_align;
  char  __ss_pad2[__SS_PAD2SIZE];
};
#endif

#define FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
// default file access permissions for new files
#define DIR_MODE (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)
// default permissions for new directories 

typedef void Sigfunc(int);           // for signal handlers 

#define min(a,b) ((a) < (b) ? (a) : (b))
#define max(a,b) ((a) > (b) ? (a) : (b))

#ifndef HAVE_ADDRINFO_STRUCT
# include "../addrinfo.h"
#endif

#ifndef HAVE_IF_NAMEINDEX_STRUCT
struct if_nameindex{
  unsigned int   if_index;           // 1, 2, ...
  char          *if_name;            // null-terminated name: "le0", ... 
};
#endif

#ifndef HAVE_TIMESPEC_STRUCT
struct timespec {
  time_t tv_sec;                     // seconds
  long  tv_nsec;                     // and nanoseconds
};
#endif

#ifdef IPV6
const struct in6_addr in6addr_any;
#endif


/*
  prototypes for library functions 
  lib_socket.c
*/
int connect_nonb(int, const SA *, socklen_t, int);
int connect_timeo(int, const SA *, socklen_t, int);
int daemon_init(const char *, int);
void daemon_inetd(const char *, int);
void dg_cli(FILE*, int, const SA *, socklen_t);
void dg_echo(int, SA*, socklen_t);
int family_to_level(int);
char* gf_time();
//void heartbeat_cli(int, int, int); // book example of heartbeat timer ???
//void heartbeat_serv(int, int, int); // book example of heartbeat timer ???
struct addrinfo* host_serv(const char *, const char *, int, int);
int inet_srcrt_add(char*); // ???
u_char* inet_srcrt_init(int); // ???
void inet_srcrt_print(u_char*, int); // ???
void inet6_srcrt_print(void*); // ???
char** my_addrs(int*); 
int readable_timeo(int, int);
ssize_t readline(int, void*, size_t); 
ssize_t readn(int, void*, size_t); 
ssize_t read_fd(int, void*, size_t, int*);
ssize_t recvfrom_flags(int, void*, size_t, int*, SA*, socklen_t*, struct socklib_in_pktinfo*); 
Sigfunc* signal_intr(int, Sigfunc*); 
int sock_bind_wild(int, int);
int sock_cmp_addr(const SA*, const SA*, socklen_t); 
int sock_cmp_port(const SA*, const SA*, socklen_t); 
int sock_get_port(const SA*, socklen_t);
void sock_set_addr(SA*, socklen_t, const void*);
void sock_set_port(SA*, socklen_t, int);
void sock_set_wild(SA*, socklen_t);
char* sock_ntop(const SA*, socklen_t);
char* sock_ntop_host(const SA*, socklen_t); 
int sockfd_to_family(int);
void str_echo(int);
void str_cli(FILE*, int);
int tcp_connect(const char*, const char*);
int tcp_listen(const char*, const char*, socklen_t*);
void tv_sub(struct timeval*, struct timeval*);
int udp_client(const char*, const char*, SA**, socklen_t*); 
int udp_connect(const char*, const char*);
int udp_server(const char*, const char*, socklen_t*);
int writable_timeo(int, int);
ssize_t writen(int, const void*, size_t);
ssize_t write_fd(int, void*, size_t, int);


/*
  multicast functions

  mcast.c
//*/
#ifdef MCAST
int mcast_leave(int, const SA *, socklen_t);
int mcast_join(int, const SA *, socklen_t, const char *, u_int);
int mcast_leave_source_group(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
int mcast_join_source_group(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen, const char *ifname, u_int ifindex);
int mcast_block_source(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
int mcast_unblock_source(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
int mcast_get_if(int); 
int mcast_get_loop(int);
int mcast_get_ttl(int); 
int mcast_set_if(int, const char *, u_int);
int mcast_set_loop(int, int);
int mcast_set_ttl(int, int);

void _mcast_leave(int, const SA *, socklen_t);
void _mcast_join(int, const SA *, socklen_t, const char *, u_int);
void _mcast_leave_source_group(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
void _mcast_join_source_group(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen, const char *ifname, u_int ifindex);
void _mcast_block_source(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
void _mcast_unblock_source(int sockfd, const SA *src, socklen_t srclen, const SA *grp, socklen_t grplen);
int _mcast_get_if(int); 
int _mcast_get_loop(int);
int _mcast_get_ttl(int); 
void _mcast_set_if(int, const char *, u_int);
void _mcast_set_loop(int, int);
void _mcast_set_ttl(int, int);
#endif // MCAST


uint16_t in_cksum(uint16_t *, int);


#ifndef HAVE_GETADDRINFO_PROTO
int getaddrinfo(const char *, const char *, const struct addrinfo *, struct addrinfo **);
void freeaddrinfo(struct addrinfo *);
char *gai_strerror(int);
#endif


#ifndef HAVE_GETNAMEINFO_PROTO
int getnameinfo(const SA *, socklen_t, char *, size_t, char *, size_t, int);
#endif


#ifndef HAVE_GETHOSTNAME_PROTO
int gethostname(char*, int);
#endif


#ifndef HAVE_HSTRERROR_PROTO
const char* hstrerror(int); // hstrerror.c
#endif

/*
  if_name_index.c
//*/
#ifndef HAVE_IF_NAMETOINDEX_PROTO
unsigned int if_nametoindex(const char*);
char* if_indextoname(unsigned int, char*);
void if_freenameindex(struct if_nameindex*);
struct if_nameindex* if_nameindex();
#endif


/*
  wrap_lib.c
*/
#ifndef HAVE_INET_PTON_PROTO
int inet_pton(int, const char *, void *);
const char *inet_ntop(int, const void *, char *, size_t);
#endif


#ifndef HAVE_INET_ATON_PROTO
int inet_aton(const char *, struct in_addr *);
#endif


#ifndef HAVE_PSELECT_PROTO
int pselect(int, fd_set *, fd_set *, fd_set *, const struct timespec *, const sigset_t *); // pselect.c
#endif


#ifndef HAVE_SOCKATMARK_PROTO
int sockatmark(int); // sockatmark.c
#endif


#ifndef HAVE_SNPRINTF_PROTO
int snprintf(char *, size_t, const char *, ...); // snprintf.c
#endif


/* 
   prototypes for library functions 

   socket_lib.c
//*/
void _connect_timeo(int, const SA *, socklen_t, int);
int _family_to_level(int);
struct addrinfo* _host_serv(const char*, const char*, int, int);
const char* _inet_ntop(int, const void*, char*, size_t); // wrap_lib.c
void _inet_pton(int, const char*, void*); // wrap_lib.c
char* _if_indextoname(unsigned int, char*); // if_name_index.c
unsigned int _if_nametoindex(const char*); // if_name_index.c
struct if_nameindex* _if_nameindex(); // if_name_index.c
char** _my_addrs(int*); 
ssize_t _read_fd(int, void*, size_t, int *); 
int _readable_timeo(int, int);
ssize_t _recvfrom_flags(int, void*, size_t, int*, SA*, socklen_t*, struct socklib_in_pktinfo*);
Sigfunc* _signal(int, Sigfunc*);
Sigfunc* _signal_intr(int, Sigfunc*); 
int _sock_bind_wild(int, int);
char* _sock_ntop(const SA*, socklen_t);
char* _sock_ntop_host(const SA*, socklen_t);
int _sockfd_to_family(int);
int _tcp_connect(const char*, const char*);
int _tcp_listen(const char*, const char*, socklen_t*);
int _udp_client(const char*, const char*, SA**, socklen_t*);
int _udp_connect(const char*, const char*);
int _udp_server(const char*, const char*, socklen_t*);
ssize_t _write_fd(int, void*, size_t, int);
int _writable_timeo(int, int);

   
/* 
   prototypes for Unix wrapper functions: see {Sec errors} 

   wrap_unix.c
//*/
void* _calloc(size_t, size_t);
void _close(int);
void _dup2(int, int);
int _fcntl(int, int, int);
void _gettimeofday(struct timeval *, void *);
int _ioctl(int, int, void *);
pid_t _fork();
void* _malloc(size_t);
int _mkstemp(char *);
void* _mmap(void *, size_t, int, int, int, off_t);
int _open(const char *, int, mode_t);
void _pipe(int *fds);
ssize_t _read(int, void *, size_t);
void _sigaddset(sigset_t *, int);
void _sigdelset(sigset_t *, int);
void _sigemptyset(sigset_t *);
void _sigfillset(sigset_t *);
int _sigismember(const sigset_t *, int);
void _sigpending(sigset_t *);
void _sigprocmask(int, const sigset_t *, sigset_t *);
char* _strdup(const char *);
long _sysconf(int);
void _sysctl(int *, u_int, void *, size_t *, void *, size_t);
void _unlink(const char *);
pid_t _wait(int *);
pid_t _waitpid(pid_t, int *, int);
void _write(int, void *, size_t);

   
/* 
   prototypes for our stdio wrapper functions: see {Sec errors} 
   
   wrap_stdio.c
*/
void _fclose(FILE *);
FILE* _fdopen(int, const char *);
char* _fgets(char *, int, FILE *);
FILE* _fopen(const char *, const char *);
void _fputs(const char *, FILE *);


/* 
   prototypes for our socket wrapper functions: see {Sec errors} 

   wrap_sock.c
*/
int _accept(int, SA *, socklen_t *);
void _bind(int, const SA *, socklen_t);
void _connect(int, const SA *, socklen_t);
void _getpeername(int, SA *, socklen_t *);
void _getsockname(int, SA *, socklen_t *);
void _getsockopt(int, int, int, void *, socklen_t *);

/* TODO fix config.h - HP-UX!!!
#ifdef HAVE_INET6_RTH_INIT
int _inet6_rth_space(int, int);
void* _inet6_rth_init(void *, socklen_t, int, int);
void _inet6_rth_add(void *, const struct in6_addr *);
void _inet6_rth_reverse(const void *, void *);
int _inet6_rth_segments(const void *);
struct in6_addr* _inet6_rth_getaddr(const void *, int);
#endif
//*/ // HP-UX

#ifdef HAVE_KQUEUE
int _kqueue();
int _kevent(int, const struct kevent *, int, struct kevent *, int, const struct timespec *);
#endif

void _listen(int, int);

#ifdef HAVE_POLL
int _poll(struct pollfd *, unsigned long, int);
#endif

ssize_t _readline(int, void *, size_t);
ssize_t _readn(int, void *, size_t);
ssize_t _recv(int, void *, size_t, int);
ssize_t _recvfrom(int, void *, size_t, int, SA *, socklen_t *); 
ssize_t _recvmsg(int, struct msghdr *, int);
int _select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
void _send(int, const void *, size_t, int);
void _sendto(int, const void *, size_t, int, const SA *, socklen_t);
void _sendmsg(int, const struct msghdr *, int);
void _setsockopt(int, int, int, const void *, socklen_t);
void _shutdown(int, int);
int _sockatmark(int);
int _socket(int, int, int);
void _socketpair(int, int, int, int *);
void _writen(int, void *, size_t);

//  error.c
void err_dump(const char *, ...); 
void err_msg(const char *, ...); 
void err_quit(const char *, ...);
void err_ret(const char *, ...); 
void err_sys(const char *, ...); 
#endif //  unix wrappers

